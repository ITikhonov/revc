		Utilities

=utils
-def resolve_type(t,name=None):
-	c=[]
-	for x in t.c:
-		if x=='ptr': c.append('*')
-		elif x.startswith('[') and name:
-			c.append(name)
-			name=None
-			c.append(x)
-		else: c.append(x)
-	if name: c.append(name)
-	return ' '.join(c)

-def func_decl(name,rtype,args):
-	rtype=resolve_type(rtype)
-	args=[resolve_type(args[i+1],args[i]) for i in range(0,len(args),2)]
-	return "%s %s(%s)"%(rtype,name,','.join(args))


		Compiler

=compiler
-comps={}

-def c_func(t,c):
-	_,args,body,name=t
-	c.code.append(func_decl(name,args[0],args[1:]))
-	c.code.append('{')
-	compiler(body,c)
-	c.code.append('}')

-comps['func']=c_func

-def c_assignvar(t,c):
-	_,vt,name,value=t
-	c.code.append(resolve_type(vt,name))
-	c.code.append('=')
-	compile(value,c)
-	c.code.append(';')
-comps['assignvar']=c_assignvar

-def c_funcall(t,c):
-	_,name,args=t
-	c.code.append(name)
-	c.code.append('(')
-	cargs=[]
-	for x in args:
-		compile(x,c)
-		c.code.append(',')
-	c.code.pop()
-	c.code.append(')')
-comps['funcall']=c_funcall


-def c_pfield(t,c):
-	_,f,s=t
-	compile(s,c)
-	c.code.append('->')
-	c.code.append(f)
-comps['<-']=c_pfield


-def c_for(t,c):
-	_,cond,next,body=t
-	c.code.append('for(;')
-	compile(cond,c)
-	c.code.append(';')
-	compile(next,c)
-	c.code.append(') {')
-	compiler(body,c)
-	c.code.append('}')
-comps['for']=c_for

-def compile(expr,c):
-	if type(expr)==tuple:
-		comps[expr[0]](expr,c)
-	else:
-		c.code.append(expr)

-def compiler(tree,c):
-	for x in tree:
-		compile(x,c)
-	return c


		Macros

=macros
-macros={}

Types

=types
-Type='Type'

-def macro_char(c,t):
-	c.stack.append(O(i=Type,c=['char']))
-macros['char']=macro_char

-def macro_int(c,t):
-	c.stack.append(O(i=Type,c=['int']))
-macros['int']=macro_int

-def macro_ptr(c,t):
-	t=c.stack.pop()
-	t.c.append('ptr')
-	c.stack.append(t)
-macros['ptr']=macro_ptr

-def macro_struct(c,t):
-	t=c.stack.pop()
-	assert type(t)==str
-	c.stack.append(O(i=Type,c=['struct '+t]))
-macros['struct']=macro_struct


-def macro_array(c,t):
-	n=int(c.stack.pop())
-	t=c.stack.pop()
-	t.c.append('[%u]'%n)
-	c.stack.append(t)
-macros['array']=macro_array


-def macro_assign(c,t):
-	t=c.stack.pop()
-	if getattr(t,'i',None)==Type:
-		n=c.stack.pop()
-		v=c.stack.pop()
-		c.stack.append(('assignvar',t,n,v))
-	else:
-		v=c.stack.pop()
-		c.stack.append(('assign',t,v))
-macros['=']=macro_assign

-def macro_binop(c,t):
-	a=c.stack.pop()
-	b=c.stack.pop()
-	c.stack.append((t,b,a))
-for x in '< > + - / * == >= <= <-'.split():
-	macros[x]=macro_binop

-def macro_triop(c,t):
-	a=c.stack.pop()
-	b=c.stack.pop()
-	d=c.stack.pop()
-	c.stack.append((t,d,b,a))
-for x in 'for ifelse func'.split():
-	macros[x]=macro_triop

-def macro_infix(c,t):
-	c.stack.append((t,c.stack.pop()))
-for x in 'return ++'.split():
-	macros[x]=macro_infix

-def macro_block(c,t):
-	b=[]
-	while c.stack[-1]!='[':
-		b.insert(0,c.stack.pop())
-	c.stack.pop()
-	c.stack.append(b)
-macros[']']=macro_block


-def macro_read(c,t): # it should not be defined here but rather dynamically
-	args=[]
-	args.insert(0,c.stack.pop())
-	args.insert(0,c.stack.pop())
-	args.insert(0,c.stack.pop())
-	c.stack.append(('funcall',t,args))
-macros['read']=macro_read


=>example.revc
-[
-	char	ptr  
-	c	conn struct ptr
-	buf	char 1024 array
-]
-[ 
-	fd c <- buf 1024 read r int =
-	0 i int = i r < i ++ [
-		i buf [] "\r\n\r\n" reg c <- ==
-		[ reg c <- ++ ]
-		[ 0 reg c <- = ] ifelse
-
-		[ reg c <- ] 4 == [ buf i 1 + + return ]
-	] for
-	0 return
-] skip_header func



=parse-one
-def parse_one(c,text):
-	if text.startswith('"'):
-		t,rest=text[1:].split('"',1)
-		c.stack.append('"'+t+'"')
-		return rest
-	s=text.split(None,1)
-	t,rest=s if len(s)==2 else (s[0],'')
-	if t in c.macro: c.macro[t](c,t)
-	else: c.stack.append(t)
-	return rest


=context
-class context:
-	stack=[]
-	macro=macros

=parse
-def parse(text):
-	c=context()
-	while text:
-		try: text=parse_one(c,text)
-		except:
-			print 'tripped holding',c.stack
-			print 'on',repr(text[:20])
-			raise
-	return c


=>revc.py
-from pprint import pprint as pp

-class O:
-	def __init__(_,**kw):
-		for x,y in kw.iteritems():
-			setattr(_,x,y)

-	def __repr__(_):
-		return 'O('+(', '.join([("%r=%r"%x) for x in _.__dict__.items()]))+')'

>utils
>compiler

>macros
>types
>parse-one
>parse
>context


-if __name__=='__main__':
-	from sys import argv
-	c=parse(open(argv[1]).read())
-	pp(c.stack,indent=8)
-	c.code=[]
-	try: c=compiler(c.stack,c)
-	except:
-		print c.code
-		raise
-	print c.code
